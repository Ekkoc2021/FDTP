

### 核心部分



#### 统一管理线程池的组件==>容器

- 核心:提供刷新线程池参数的接口
- 其他功能: 线程池监控接口
- 能够接管已有旧线程池: 接管旧线程池
  应用里面已经定义好的线程池,也能够在尽量少的修改源代码的情况下适配到容器==>比如说也能够管理tomcat/dubbo的线程池

> 创建线程池==>注册到线程池管理组件==>应用运行
>
> 根据业务和需求场景不重启应用动态刷新线程池参数 

告警功能: 在同一管理组件里面添加定时任务,定时对组件内所有的线程池做一个扫描
资源告警相关的问题: 如达到任务队列占用量时,每次添加任务都可能会触发一次对应线程池的告警(告警风暴)

- 一些可能有用的指标
  线程池线程资源利用率 : 活跃线程池/maxPoolSize
  任务队列占用量: 队列任务数量/总容量
  拒绝量: 拒绝任务量/总任务量
  任务执行成功率: 无异常的任务/总执行的任务  
  任务处理速率: 单位时间内的任务完成率 
  任务增长速率: 单位时间内增长的任务量 



线程池管理相关参数

- 分组,应用名称,描述





#### 动态线程池实现 : DT

核心参数

- corePoolSize : 核心线程池数量
- maximumPoolSize : 最大线程池数量
- activeCount : 活跃线程数量,当前正在执行任务的线程
- poolSize: 线程池中的线程数量
- largestPoolSize : 最大线程数量
- waitingSize : 队列中的任务量
- queueMaxSize : 队列最大长度
- taskCount: 任务量
- completedTasks : 已经完成的任务量
- errorSize : 异常任务量,封装runable捕获异常即可
- rejectSize : 拒绝的任务量



> 具体实现动态刷新所有参数的功能
>
> 动态修改线程池实现的功能: 从普通的jdk线程池,其他的线程池实现

- 线程池类型: 普通jdk线程池,支持虚拟线程的线程池池,其他类型的线程池(disruptor实现)
  自定义一个可动态修改线程池参数的类 ==> 只要实现这个类都可以注册到线程池容器中
- 线程池拒接策略: 类似aop的机制,增强原有拒绝策略,告警机制等等



线程池类型

- JDK线程池: 核心参数设置方案,jdk提供有设置参数的接口
  阻塞队列动态伸缩问题
- 支持虚拟线程: 就是普通jdk的扩展性
- dsruptor实现的线程池: 需要封装成和普通线程池一样的参数,切换就采用直接替换掉原有线程池对象



线程池的一些扩展点:方便后续在统一管理部分做接口扩展

- 线程池参数变更扩展点handler : 允许在变更前和后做一些处理,如配置入库
- 线程池拒绝策略扩展点handler:  在执行具体拒绝策略时做一些处理, 通常来说拒绝任务说明当前线程池参数不适合当前场景,需要进行调整,如发邮件通知等操作
- 提交任务扩展点: 感觉没有什么意义!
- 任务执行扩展点: 重新包装传入的runable对象 ==> 可以用来统计任务失败数量,这个应该会有用



线程池核心参数:

- corePoolSize : 核心线程池的大小，如果核心线程池有空闲位置，这时新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。
- maximunPoolSize : 最大线程池数量,超过这个数量,新任务到达会放入阻塞队列
- workQueue : 阻塞队列,jdk队列不支持动态修改容量,需要解决
- 拒绝策略 :增强拒绝策略,一些告警机制通知通过拒接策略去实现

动态线程池参数:

- 线程池参数这部分可以考虑就只和线程池运行机制相关
- 和业务相关尽量放到管理组件去定义: 1.方便后续扩展,2.分层管理



   

disruptor封装成线程池接口

- 将disruptor封装成线程池的接口
- disruptor的动态参数设置 : 可以通过切换disruptor对象
  拒绝策略:统一封装的线程策略

> 





### 线程池监控面板

不依赖第三方注册中心,实现统一的线程池管理



### starter

集成到boot应用

基于core:开发springboot组件,适配zk/nacos注册中心,实现通过注册中心动态刷新线程池



### 适配一些观测性组件

Prometheus

